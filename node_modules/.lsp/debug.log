Hello - from /Users/prisc_000/.vscode/extensions/jaredly.reason-vscode-1.7.5/bin.native
Previous log location: /var/folders/dz/xzttny_14gs2lgxcvl5lm5680000gn/T/lsp.log
Sending notification {"jsonrpc": "2.0", "method": "client/registerCapability", "params": {"registrations": [{"id": "watching", "method": "workspace/didChangeWatchedFiles", "registerOptions": {"watchers": [{"globPattern": "**/bsconfig.json"}, {"globPattern": "**/.merlin"}]}}]}}
Sending response {"id": 0, "jsonrpc": "2.0", "result": {"capabilities": {"textDocumentSync": 1, "hoverProvider": true, "completionProvider": {"resolveProvider": true, "triggerCharacters": ["."]}, "signatureHelpProvider": {"triggerCharacters": ["("]}, "definitionProvider": true, "typeDefinitionProvider": true, "referencesProvider": true, "documentSymbolProvider": true, "codeActionProvider": true, "executeCommandProvider": {"commands": ["reason-language-server.add_to_interface_inner"]}, "codeLensProvider": {"resolveProvider": true}, "documentHighlightProvider": true, "documentRangeFormattingProvider": true, "documentFormattingProvider": true, "renameProvider": true}}}
Read message 
{"jsonrpc":"2.0","method":"initialized","params":{}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeConfiguration","params":{"settings":{"reason_language_server":{"location":"","build_system_override_by_root":{},"refmt":"","lispRefmt":"","mlfmt":"","format_width":80,"per_value_codelens":true,"dependencies_codelens":true,"opens_codelens":true,"show_module_path_on_hover":true,"reloadOnChange":false,"show_debug_errors":false,"autoRebuild":true,"useOldDuneProcess":false}}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/counter_server.ml","languageId":"ocaml","version":1,"text":"(** Multi-client server example.\n\n    Clients can increment a shared counter or read its current value.\n\n    Build with: ocamlfind ocamlopt -package lwt,lwt.unix,logs,logs.lwt -linkpkg -o counter-server ./counter-server.ml\n *)\n\nopen Lwt\n\n(* Shared mutable counter *)\nlet counter = ref 0\n\nlet listen_address = Unix.inet_addr_loopback\nlet port = 9000\nlet backlog = 10\n\n\nlet handle_message msg =\n    match msg with\n    | \"read\" -> string_of_int !counter\n    | \"inc\"  -> counter := !counter + 1; \"Counter has been incremented\"\n    | _      -> \"Unknown command\"\n\nlet rec handle_connection ic oc () =\n    Lwt_io.read_line_opt ic >>=\n    (fun msg ->\n        match msg with\n        | Some msg ->\n            let reply = handle_message msg in\n            Lwt_io.write_line oc reply >>= handle_connection ic oc\n        | None -> Logs_lwt.info (fun m -> m \"Connection closed\") >>= return)\n\nlet accept_connection conn =\n    let fd, _ = conn in\n    let ic = Lwt_io.of_fd ~mode:Lwt_io.Input fd in\n    let oc = Lwt_io.of_fd ~mode:Lwt_io.Output fd in\n    Lwt.on_failure (handle_connection ic oc ()) (fun e -> Logs.err (fun m -> m \"%s\" (Printexc.to_string e) ));\n    Logs_lwt.info (fun m -> m \"New connection\") >>= return\n(* let accept_connection conn =\n  let fd, _ = conn in\n  let input_console = Lwt_io.of_fd Lwt_io.Input fd in\n  let output_console = Lwt_io.of_fd Lwt_io.Output fd in\n  Lwt.on_failure (handle_connection input_console output_console 0 ())\n    (fun e -> Logs.err (fun m -> m \"%s\" (Printexc.to_string e)));\n  Logs_lwt.info (fun m -> m \"New connection\") >>= return *)\n(*\nlet create_socket () =\n  let open Lwt_unix in\n  let sock = socket PF_INET SOCK_STREAM 0 in\n  (bind sock @@ ADDR_INET(listen_address, port);\n   listen sock backlog;\n   sock) *)\nlet create_socket () =\n    let open Lwt_unix in\n    let sock = socket PF_INET SOCK_STREAM 0 in\n    ignore @@ bind sock @@ ADDR_INET(listen_address, port);\n    || maybe ADDR_INET(listen_address, port) |> bind sock\n\nlet create_server sock =\n    let rec serve () =\n        Lwt_unix.accept sock >>= accept_connection >>= serve\n    in serve\n\nlet () =\n    let () = Logs.set_reporter (Logs.format_reporter ()) in\n    let () = Logs.set_level (Some Logs.Info) in\n    let sock = create_socket () in\n    let serve = create_server sock in\n    Lwt_main.run @@ serve ()\n\n"}}}
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml
=== Project root: /Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
New dune process
[MerlinFile]: Error: Insufficient build files found for module Logs_top_init - src: /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/logs/logs_top_init.ml, srci: (), cmi: (), cmt: (), cmti: ()
[MerlinFile]: Error: Insufficient build files found for module Logs_fmt_top_init - src: /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/logs/logs_fmt_top_init.ml, srci: (), cmi: (), cmt: (), cmti: ()
[MerlinFile]: Error: Insufficient build files found for module Counter_server - src: /Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/counter_server.ml, srci: (), cmi: (), cmt: (), cmti: ()
>> Build system running: opam exec -- dune build @install --root .
>>> stdout

>>> stderr

Affected files: 
Cleaning bsconfig.json
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/bsconfig.json", "diagnostics": []}}
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/random.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/nat.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/map.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/topdirs.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/genlex.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stack.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/hashtbl.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/parsing.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/parsing.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/arith_status.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stream.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/callback.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/random.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/lazy.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/format.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_bytes.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_unix.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_io.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/list.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/string.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stringLabels.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalOO.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_throttle.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/arg.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_switch.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/gc.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_process.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/bytes.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_pool.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_features.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/marshal.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/format.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_condition.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/listLabels.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/list.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/sort.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/logs/logs.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_result.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/digest.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/oo.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/printexc.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/hashtbl.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/scanf.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/uchar.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/nativeint.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/raw_spacetime_lib.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/bigarray.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/set.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_gc.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/bytes.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalLazy.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_sequence.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_timeout.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/condition.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stream.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalOO.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/logs/logs_lwt.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/str.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/map.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_list.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/float.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/char.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/queue.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/seq.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/arrayLabels.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/sys.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_pool.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/listLabels.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/callback.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/printf.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/oo.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/spacetime.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_bytes.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocplib-endian/endianString.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/complex.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalFormatBasics.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_mutex.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/genlex.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/unixLabels.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/logs/logs_fmt.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdLabels.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/buffer.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/array.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/logs/logs_threaded.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/logs/logs_browser.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalFormat.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/uchar.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_engine.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/lexing.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/int64.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_config.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_sys.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalFormatBasics.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/mmap/mmap.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocplib-endian/endianBigstring.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/sort.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_process.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/thread.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stack.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalLazy.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/char.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_sys.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_stream.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/printf.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/big_int.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/result/result.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/set.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/array.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_engine.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocplib-endian/endianBytes.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_gc.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/string.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/std_exit.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/buffer.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/float.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_preemptive.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/filename.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_timeout.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/bigarray.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/scanf.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/sys.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/obj.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/num.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/weak.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_io.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/moreLabels.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/lexing.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/queue.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_fmt.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_main.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_mvar.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_throttle.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/int32.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_condition.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/filename.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/arg.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/lazy.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/arrayLabels.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_preemptive.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_pqueue.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_unix.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalMod.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_result.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_mvar.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/gc.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_fmt.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/mmap/mmap.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/obj.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/complex.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/ephemeron.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/bytesLabels.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/digest.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/event.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/ephemeron.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/bytesLabels.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/spacetime.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/printexc.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/marshal.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/unix.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/nativeint.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stringLabels.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/logs/logs_cli.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_main.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_pqueue.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/int32.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_stream.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_mutex.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/mutex.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalMod.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalFormat.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/seq.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/int64.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/threadUnix.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_list.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdLabels.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/weak.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_switch.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_sequence.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/dynlink.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/moreLabels.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/ratio.mli
Reloading because you created a new file: /Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/counter_server.ml
Running diagnostics for file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/counter_server.ml
➡️ running compiler /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/bin/ocamlopt.opt -c -I '/Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml' -I '_build/default/.counter_server.eobjs/byte' -I '/Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/seq' -I '/Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/result' -I '/Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocplib-endian' -I '/Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/threads' -I '/Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml' -I '/Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/mmap' -I '/Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix' -I '/Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt' -I '/Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/logs' -I '/Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/bytes' -bin-annot -w @1..3@5..28@30..39@43@46..47@49..57@61..62-40 -strict-sequence -strict-formats -short-paths -keep-locs -impl /Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/_build/.lsp/Counter_server.ast with pwd /Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml
Now loading /Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/_build/.lsp/Counter_server.cmt
Size 24502
<< Making lastDefinitions with type error for file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/counter_server.ml
type error here File "/Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/_build/.lsp/Counter_server.ast", line 56, characters 4-58:
Error: This expression has type unit but an expression was expected of type
         bool
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/counter_server.ml", "diagnostics": [{"range": {"start": {"line": 55, "character": 4}, "end": {"line": 55, "character": 58}}, "message": "Error: This expression has type unit but an expression was expected of type\n         bool", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":1,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/counter_server.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Sending response {"id": 1, "jsonrpc": "2.0", "result": [{"name": "accept_connection", "kind": 12, "location": {"range": {"start": {"line": 32, "character": 0}, "end": {"line": 37, "character": 58}}, "uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/_build/.lsp/Counter_server.ast"}}, {"name": "handle_connection", "kind": 12, "location": {"range": {"start": {"line": 23, "character": 0}, "end": {"line": 30, "character": 76}}, "uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/_build/.lsp/Counter_server.ast"}}, {"name": "handle_message", "kind": 12, "location": {"range": {"start": {"line": 17, "character": 0}, "end": {"line": 21, "character": 33}}, "uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/_build/.lsp/Counter_server.ast"}}, {"name": "backlog", "kind": 13, "location": {"range": {"start": {"line": 14, "character": 0}, "end": {"line": 14, "character": 16}}, "uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/_build/.lsp/Counter_server.ast"}}, {"name": "port", "kind": 13, "location": {"range": {"start": {"line": 13, "character": 0}, "end": {"line": 13, "character": 15}}, "uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/_build/.lsp/Counter_server.ast"}}, {"name": "listen_address", "kind": 13, "location": {"range": {"start": {"line": 12, "character": 0}, "end": {"line": 12, "character": 44}}, "uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/_build/.lsp/Counter_server.ast"}}, {"name": "counter", "kind": 13, "location": {"range": {"start": {"line": 10, "character": 0}, "end": {"line": 10, "character": 19}}, "uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/_build/.lsp/Counter_server.ast"}}]}
Read message 
{"jsonrpc":"2.0","id":2,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/counter_server.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":70,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0178813934326ms
Sending response {"id": 2, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":3,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/counter_server.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00786781311035ms
Sending response {"id": 3, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Logs_lwt, Unix, Logs, Stdlib, Lwt_unix, CamlinternalFormatBasics, Lwt_io, Lwt", "command": ""}}, {"range": {"start": {"line": 32, "character": 4}, "end": {"line": 32, "character": 21}}, "command": {"title": "((Lwt_unix.file_descr, 'a)) => Lwt.t(\n  unit\n)", "command": ""}}, {"range": {"start": {"line": 23, "character": 8}, "end": {"line": 23, "character": 25}}, "command": {"title": "(\n  Lwt_io.input_channel,\n  Lwt_io.output_channel,\n  unit\n) => Lwt.t(unit)", "command": ""}}, {"range": {"start": {"line": 17, "character": 4}, "end": {"line": 17, "character": 18}}, "command": {"title": "string => string", "command": ""}}, {"range": {"start": {"line": 14, "character": 4}, "end": {"line": 14, "character": 11}}, "command": {"title": "int", "command": ""}}, {"range": {"start": {"line": 13, "character": 4}, "end": {"line": 13, "character": 8}}, "command": {"title": "int", "command": ""}}, {"range": {"start": {"line": 12, "character": 4}, "end": {"line": 12, "character": 18}}, "command": {"title": "Unix.inet_addr", "command": ""}}, {"range": {"start": {"line": 10, "character": 4}, "end": {"line": 10, "character": 11}}, "command": {"title": "Stdlib.ref(int)", "command": ""}}, {"range": {"start": {"line": 7, "character": 5}, "end": {"line": 7, "character": 8}}, "command": {"title": "Unused open", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":4,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/counter_server.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":70,"character":0}},"context":{"diagnostics":[{"range":{"start":{"line":55,"character":4},"end":{"line":55,"character":58}},"message":"Error: This expression has type unit but an expression was expected of type\n         bool","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00905990600586ms
Sending response {"id": 4, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":2}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwolwt.re","languageId":"reason","version":1,"text":""}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":5,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwolwt.re"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0250339508057ms
Sending response {"id": 5, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":6,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwolwt.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0247955322266ms
Sending response {"id": 6, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwolwt.re"}}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","languageId":"reason","version":1,"text":""}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":7,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0169277191162ms
Sending response {"id": 7, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":8,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0169277191162ms
Sending response {"id": 8, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/counter_server.ml"}}}
Read message 
{"jsonrpc":"2.0","id":9,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0300407409668ms
Sending response {"id": 9, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":2},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n\n/* Async Basics */\n\nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Read message 
{"jsonrpc":"2.0","id":10,"method":"textDocument/rangeFormatting","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"range":{"start":{"line":0,"character":0},"end":{"line":417,"character":0}},"options":{"tabSize":2,"insertSpaces":true}}}
[server] Got a method textDocument/rangeFormatting
[server] processing took 0.0131130218506ms
Sending response {"id": 10, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":11,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Sending response {"id": 11, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: No root directory found", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":12,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00691413879395ms
Sending response {"id": 12, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":2},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n\n/* Async Basics */\n\nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":2}}}
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":13,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"position":{"line":176,"character":57}}}
[server] Got a method textDocument/hover
[server] processing took 0.0250339508057ms
Sending response {"id": 13, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":14,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"position":{"line":198,"character":38}}}
[server] Got a method textDocument/hover
[server] processing took 0.0259876251221ms
Sending response {"id": 14, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":15,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"position":{"line":201,"character":38}}}
[server] Got a method textDocument/hover
[server] processing took 0.0162124633789ms
Sending response {"id": 15, "jsonrpc": "2.0", "error": {"code": -32603, "message": "No root directory found"}}
Read message 
{"jsonrpc":"2.0","id":16,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0309944152832ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 16, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":17,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0369548797607ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 17, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":16}}
Read message 
{"jsonrpc":"2.0","id":18,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"range":{"start":{"line":78,"character":21},"end":{"line":78,"character":21}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0259876251221ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 18, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":19,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"position":{"line":69,"character":26}}}
[server] Got a method textDocument/hover
[server] processing took 0.00905990600586ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 19, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":19}}
Read message 
{"jsonrpc":"2.0","id":20,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"position":{"line":370,"character":21}}}
[server] Got a method textDocument/hover
[server] processing took 0.0400543212891ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 20, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":21,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"position":{"line":7,"character":16}}}
[server] Got a method textDocument/hover
[server] processing took 0.0240802764893ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 21, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":21}}
Read message 
{"jsonrpc":"2.0","id":22,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"position":{"line":5,"character":16}}}
[server] Got a method textDocument/hover
[server] processing took 0.0259876251221ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 22, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":22}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":3},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n// \n/* Async Basics */\n\nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Read message 
{"jsonrpc":"2.0","id":23,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00882148742676ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 23, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":24,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00905990600586ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 24, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":3},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n// \n/* Async Basics */\n\nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":3}}}
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":4},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n//\n/* Async Basics */\n\nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Read message 
{"jsonrpc":"2.0","id":25,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0119209289551ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 25, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":26,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"range":{"start":{"line":13,"character":2},"end":{"line":13,"character":2}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 26, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":26}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":5},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n/\n/* Async Basics */\n\nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Read message 
{"jsonrpc":"2.0","id":27,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00500679016113ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 27, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":28,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"range":{"start":{"line":13,"character":1},"end":{"line":13,"character":1}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 28, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":29,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 29, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":5},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n/\n/* Async Basics */\n\nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":5}}}
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":6},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n/*\n/* Async Basics */\n\nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Read message 
{"jsonrpc":"2.0","id":30,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 30, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":31,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"range":{"start":{"line":13,"character":2},"end":{"line":13,"character":2}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00977516174316ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 31, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Read message 
{"jsonrpc":"2.0","id":32,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 32, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":7},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n/* \n/* Async Basics */\n\nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Read message 
{"jsonrpc":"2.0","id":33,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 33, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin", "command": ""}}]}
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":32}}
Read message 
{"jsonrpc":"2.0","id":34,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0131130218506ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 34, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":7},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n/* \n/* Async Basics */\n\nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":7}}}
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":8},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n/* *\n/* Async Basics */\n\nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Read message 
{"jsonrpc":"2.0","id":35,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0178813934326ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 35, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":36,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"range":{"start":{"line":13,"character":4},"end":{"line":13,"character":4}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0169277191162ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 36, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":37,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0190734863281ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 37, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":9},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n/* *?\n/* Async Basics */\n\nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Read message 
{"jsonrpc":"2.0","id":38,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00786781311035ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 38, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":39,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"range":{"start":{"line":13,"character":5},"end":{"line":13,"character":5}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 39, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":40,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00715255737305ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 40, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":10},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n/* *\n/* Async Basics */\n\nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":10}}}
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":11},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n/* */\n/* Async Basics */\n\nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Read message 
{"jsonrpc":"2.0","id":41,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 41, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":42,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"range":{"start":{"line":13,"character":5},"end":{"line":13,"character":5}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0147819519043ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 42, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":43,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0138282775879ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 43, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Read message 
{"jsonrpc":"2.0","id":44,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"range":{"start":{"line":13,"character":3},"end":{"line":13,"character":3}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00691413879395ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 44, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":11},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n/* */\n/* Async Basics */\n\nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":11}}}
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":12},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n/* The latest version of this document is available at https://github.com/dkim/rwo-lwt/.*/\n/* Async Basics */\n\nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Read message 
{"jsonrpc":"2.0","id":45,"method":"textDocument/rangeFormatting","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"range":{"start":{"line":13,"character":3},"end":{"line":13,"character":88}},"options":{"tabSize":2,"insertSpaces":true}}}
[server] Got a method textDocument/rangeFormatting
[server] processing took 0.00810623168945ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 45, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":46,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0100135803223ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 46, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":47,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"range":{"start":{"line":13,"character":88},"end":{"line":13,"character":88}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 47, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":48,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00810623168945ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 48, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":12},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n/* The latest version of this document is available at https://github.com/dkim/rwo-lwt/.*/\n/* Async Basics */\n\nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":12}}}
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":13},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n/* The latest version of this document is available at https://github.com/dkim/rwo-lwt/. */\n/* Async Basics */\n\nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Read message 
{"jsonrpc":"2.0","id":49,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0209808349609ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 49, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":50,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"range":{"start":{"line":13,"character":89},"end":{"line":13,"character":89}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0190734863281ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 50, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":51,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0278949737549ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 51, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":52,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"position":{"line":13,"character":14}}}
[server] Got a method textDocument/hover
[server] processing took 0.0178813934326ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 52, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Read message 
{"jsonrpc":"2.0","id":53,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"position":{"line":13,"character":14}}}
[server] Got a method textDocument/hover
[server] processing took 0.0250339508057ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 53, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":13},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n/* The latest version of this document is available at https://github.com/dkim/rwo-lwt/. */\n/* Async Basics */\n\nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":13}}}
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending notification {"jsonrpc": "2.0", "method": "window/showMessage", "params": {"type": 1, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Read message 
{"jsonrpc":"2.0","id":54,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"position":{"line":52,"character":18}}}
[server] Got a method textDocument/hover
[server] processing took 0.0169277191162ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 54, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":55,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0360012054443ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 55, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":56,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 56, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Unable to load compilation data: Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":57,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"range":{"start":{"line":13,"character":89},"end":{"line":13,"character":89}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 57, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":55}}
Read message 
{"jsonrpc":"2.0","id":58,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"position":{"line":84,"character":9}}}
[server] Got a method textDocument/hover
[server] processing took 0.0138282775879ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 58, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":58}}
Read message 
{"jsonrpc":"2.0","id":59,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"position":{"line":36,"character":10}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0228881835938ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 59, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":60,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"range":{"start":{"line":36,"character":10},"end":{"line":36,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0169277191162ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 60, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","id":61,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"position":{"line":128,"character":9}}}
[server] Got a method textDocument/hover
[server] processing took 0.0209808349609ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000
Detected `esy` dependency manager for local use
Sending response {"id": 61, "jsonrpc": "2.0", "error": {"code": -32603, "message": "Unable to read /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin"}}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":61}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune/hello_world.ml","languageId":"ocaml","version":1,"text":"(*\nCreate `./dune` file then run:\n`dune install`\nBuild it by running in terminal in this dir:\n `dune build hello_world.exe`.\n Then run with `_build/default/hello_world.exe`\n  *)\nprint_endline \"Hello, world!\""}}}
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune
=== Project root: /Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
New dune process
[MerlinFile]: Error: Insufficient build files found for module Condition - src: (), srci: /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/condition.mli, cmi: (), cmt: (), cmti: ()
[MerlinFile]: Error: Insufficient build files found for module Event - src: (), srci: /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/event.mli, cmi: (), cmt: (), cmti: ()
[MerlinFile]: Error: Insufficient build files found for module Thread - src: (), srci: /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/thread.mli, cmi: (), cmt: (), cmti: ()
[MerlinFile]: Error: Insufficient build files found for module Mutex - src: (), srci: /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/mutex.mli, cmi: (), cmt: (), cmti: ()
[MerlinFile]: Error: Insufficient build files found for module ThreadUnix - src: (), srci: /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/threadUnix.mli, cmi: (), cmt: (), cmti: ()
[MerlinFile]: Error: Insufficient build files found for module Hello_world - src: /Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune/hello_world.ml, srci: (), cmi: (), cmt: (), cmti: ()
>> Build system running: opam exec -- dune build @install --root .
>>> stdout

>>> stderr

Affected files: 
Cleaning bsconfig.json
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune/bsconfig.json", "diagnostics": []}}
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/sort.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/random.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/nat.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stack.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/map.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/topdirs.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/genlex.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalLazy.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stack.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/hashtbl.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/parsing.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/parsing.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/char.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/arith_status.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stream.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/printf.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/callback.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/random.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/lazy.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/big_int.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/format.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/set.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/array.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/list.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/string.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stringLabels.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalOO.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/string.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/arg.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/std_exit.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/gc.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/buffer.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/float.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/bytes.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/filename.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/bigarray.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/scanf.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/marshal.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/format.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/sys.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/listLabels.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/obj.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/num.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/list.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/weak.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/sort.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/digest.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/oo.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/printexc.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/moreLabels.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/hashtbl.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/lexing.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/scanf.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/uchar.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/queue.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/nativeint.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/int32.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/raw_spacetime_lib.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/bigarray.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/filename.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/set.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/arg.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/lazy.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/bytes.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/arrayLabels.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalLazy.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stream.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalMod.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalOO.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/gc.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/str.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/map.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/float.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/char.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/queue.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/obj.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/complex.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/seq.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/arrayLabels.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/sys.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/ephemeron.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/listLabels.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/bytesLabels.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/callback.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/printf.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/oo.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/spacetime.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/digest.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/ephemeron.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/bytesLabels.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/spacetime.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/complex.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalFormatBasics.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/printexc.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/marshal.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/unix.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/nativeint.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stringLabels.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/genlex.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/unixLabels.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/int32.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdLabels.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/buffer.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/array.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalMod.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalFormat.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/seq.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/int64.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalFormat.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/uchar.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/lexing.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/int64.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdLabels.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/weak.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalFormatBasics.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/dynlink.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/moreLabels.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/ratio.mli
Reloading because you created a new file: /Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune/hello_world.ml
Running diagnostics for file:///Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune/hello_world.ml
➡️ running compiler /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/bin/ocamlopt.opt -c -I '/Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml' -I '_build/default/.hello_world.eobjs/byte' -bin-annot -w @1..3@5..28@30..39@43@46..47@49..57@61..62-40 -strict-sequence -strict-formats -short-paths -keep-locs -impl /Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune/_build/.lsp/Hello_world.ast with pwd /Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune
<< Replacing lastDefinitions for file:///Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune/hello_world.ml
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune/hello_world.ml", "diagnostics": []}}
Read message 
{"jsonrpc":"2.0","id":62,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune/hello_world.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00596046447754ms
Sending response {"id": 62, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":63,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune/hello_world.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00500679016113ms
Sending response {"id": 63, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","id":64,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune/hello_world.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.014066696167ms
Sending response {"id": 64, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Stdlib", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":65,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune/hello_world.ml"},"range":{"start":{"line":3,"character":1},"end":{"line":3,"character":1}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00715255737305ms
Sending response {"id": 65, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":62}}
Read message 
{"jsonrpc":"2.0","id":66,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune/hello_world.ml"},"position":{"line":5,"character":19}}}
[server] Got a method textDocument/hover
[server] processing took 0.00500679016113ms
Sending response {"id": 66, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":66}}
Read message 
{"jsonrpc":"2.0","id":67,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune/hello_world.ml"},"position":{"line":5,"character":19}}}
[server] Got a method textDocument/hover
[server] processing took 0.00691413879395ms
Sending response {"id": 67, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":68,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune/hello_world.ml"},"position":{"line":1,"character":20}}}
[server] Got a method textDocument/hover
[server] processing took 0.0119209289551ms
Sending response {"id": 68, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":69,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune/hello_world.ml"},"position":{"line":1,"character":20}}}
[server] Got a method textDocument/hover
[server] processing took 0.0131130218506ms
Sending response {"id": 69, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":70,"method":"textDocument/documentHighlight","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune/hello_world.ml"},"position":{"line":1,"character":20}}}
[server] Got a method textDocument/documentHighlight
[server] processing took 0.0579357147217ms
Sending response {"id": 70, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":71,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune/hello_world.ml"},"range":{"start":{"line":1,"character":20},"end":{"line":1,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0147819519043ms
Sending response {"id": 71, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":72,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune/hello_world.ml"},"position":{"line":3,"character":20}}}
[server] Got a method textDocument/hover
[server] processing took 0.0231266021729ms
Sending response {"id": 72, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":73,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune/hello_world.ml"},"position":{"line":4,"character":20}}}
[server] Got a method textDocument/hover
[server] processing took 0.0190734863281ms
Sending response {"id": 73, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":74,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune/hello_world.ml"},"position":{"line":4,"character":13}}}
[server] Got a method textDocument/hover
[server] processing took 0.0209808349609ms
Sending response {"id": 74, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":75,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune/hello_world.ml"},"position":{"line":4,"character":13}}}
[server] Got a method textDocument/hover
[server] processing took 0.0228881835938ms
Sending response {"id": 75, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeWatchedFiles","params":{"changes":[{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/_build/default/.merlin","type":1},{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin","type":1}]}}
Got a watched file change
Read message 
{"jsonrpc":"2.0","id":76,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.032901763916ms
Found a `dune` file at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
]] Making a new jbuilder package at /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
=== Project root: /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
Detected `opam` dependency manager for local use
Get ocaml stdlib dirs
New dune process
[MerlinFile]: Error: Insufficient build files found for module Condition - src: (), srci: /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/condition.mli, cmi: (), cmt: (), cmti: ()
[MerlinFile]: Error: Insufficient build files found for module Event - src: (), srci: /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/event.mli, cmi: (), cmt: (), cmti: ()
[MerlinFile]: Error: Insufficient build files found for module Thread - src: (), srci: /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/thread.mli, cmi: (), cmt: (), cmti: ()
[MerlinFile]: Error: Insufficient build files found for module Mutex - src: (), srci: /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/mutex.mli, cmi: (), cmt: (), cmti: ()
[MerlinFile]: Error: Insufficient build files found for module ThreadUnix - src: (), srci: /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/threadUnix.mli, cmi: (), cmt: (), cmti: ()
[MerlinFile]: Error: Insufficient build files found for module RwoLwt - src: /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re, srci: (), cmi: (), cmt: (), cmti: ()
>> Build system running: opam exec -- dune build @install --root .
>>> stdout

>>> stderr

Affected files: 
Cleaning bsconfig.json
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/bsconfig.json", "diagnostics": []}}
➡️ running compiler /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/bin/ocamlopt.opt -c -I '/Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml' -I '_build/default/.rwoLwt.eobjs/byte' -bin-annot -w @1..3@5..28@30..39@43@46..47@49..57@61..62-40 -strict-sequence -strict-formats -short-paths -keep-locs -impl /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/_build/.lsp/RwoLwt.ast with pwd /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
Now loading /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/_build/.lsp/RwoLwt.cmt
Size 2031
<< Making lastDefinitions with type error for file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re
Sending response {"id": 76, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":77,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
Sending response {"id": 77, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: ", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":78,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"range":{"start":{"line":36,"character":10},"end":{"line":36,"character":10}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0457763671875ms
Sending response {"id": 78, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":76}}
Read message 
{"jsonrpc":"2.0","id":79,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"position":{"line":14,"character":5}}}
[server] Got a method textDocument/hover
[server] processing took 0.014066696167ms
Sending response {"id": 79, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":14},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n/* The latest version of this document is available at https://github.com/dkim/rwo-lwt/. */\n/* Async Basics */\no\nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Read message 
{"jsonrpc":"2.0","id":80,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"position":{"line":15,"character":1},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0219345092773ms
Opens folkz > 0 
Package opens Pervasives
Package opens Stdlib
FINDING docs for module IntfAndImpl(/Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.cmti, /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli, /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.cmt, /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.ml)
FINDING /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.cmti src /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli
Opens nows 1 file:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli
---------------- LOCAL VAL
 - Completing in file:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli
 -- not capitalized
Sending response {"id": 80, "jsonrpc": "2.0", "result": [{"label": "open_in_gen", "kind": 12, "detail": "(\n  list(open_flag),\n  int,\n  string\n) => in_channel", "documentation": "`open_in_gen mode perm filename` opens the named file for reading, as described above. The extra arguments `mode` and `perm` specify the opening mode and file permissions. open_in and open_in_bin are special cases of this function.\n\n\n\nfile:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli:1"}, {"label": "open_out_gen", "kind": 12, "detail": "(\n  list(open_flag),\n  int,\n  string\n) => out_channel", "documentation": "`open_out_gen mode perm filename` opens the named file for writing, as described above. The extra argument `mode` specifies the opening mode. The extra argument `perm` specifies the file permissions, in case the file must be created. open_out and open_out_bin are special cases of this function.\n\n\n\nfile:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli:1"}, {"label": "output_binary_int", "kind": 12, "detail": "(out_channel, int) => unit", "documentation": "Write one integer in binary format \\(4 bytes, big-endian\\) on the given output channel. The given integer is taken modulo 2Superscript. The only reliable way to read it back is through the input_binary_int function. The format is compatible across all machines for a given version of OCaml.\n\n\n\nfile:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli:1"}, {"label": "open_out", "kind": 12, "detail": "string => out_channel", "documentation": "Open the named file for writing, and return a new output channel on that file, positioned at the beginning of the file. The file is truncated to zero length if it already exists. It is created if it does not already exists.\n\n\n\nfile:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli:1"}, {"label": "out_channel_length", "kind": 12, "detail": "out_channel => int", "documentation": "Return the size \\(number of characters\\) of the regular file on which the given channel is opened. If the channel is opened on a file that is not a regular file, the result is meaningless.\n\n\n\nfile:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli:1"}, {"label": "output_char", "kind": 12, "detail": "(out_channel, char) => unit", "documentation": "Write the character on the given output channel.\n\n\n\nfile:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli:1"}, {"label": "output_bytes", "kind": 12, "detail": "(out_channel, bytes) => unit", "documentation": "Write the byte sequence on the given output channel.\n\nSince: 4.02.0\n\nfile:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli:1"}, {"label": "open_in", "kind": 12, "detail": "string => in_channel", "documentation": "Open the named file for reading, and return a new input channel on that file, positioned at the beginning of the file.\n\n\n\nfile:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli:1"}, {"label": "output_value", "kind": 12, "detail": "(out_channel, 'a) => unit", "documentation": "Write the representation of a structured value of any type to a channel. Circularities and sharing inside the value are detected and preserved. The object can be read back, by the function input_value. See the description of module Marshal for more information. output_value is equivalent to to_channel with an empty list of flags.\n\n\n\nfile:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli:1"}, {"label": "output", "kind": 12, "detail": "(out_channel, bytes, int, int) => unit", "documentation": "`output oc buf pos len` writes `len` characters from byte sequence `buf`, starting at offset `pos`, to the given output channel `oc`. Raise `Invalid_argument \"output\"` if `pos` and `len` do not designate a valid range of `buf`.\n\n\n\nfile:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli:1"}, {"label": "open_in_bin", "kind": 12, "detail": "string => in_channel", "documentation": "Same as open_in, but the file is opened in binary mode, so that no translation takes place during reads. On operating systems that do not distinguish between text mode and binary mode, this function behaves like open_in.\n\n\n\nfile:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli:1"}, {"label": "or", "kind": 12, "detail": "(bool, bool) => bool", "documentation": "Deprecated: \\( || \\) should be used instead. Right-associative operator at precedence level 2/11.\n\n\n\n\n\nfile:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli:1"}, {"label": "output_string", "kind": 12, "detail": "(out_channel, string) => unit", "documentation": "Write the string on the given output channel.\n\n\n\nfile:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli:1"}, {"label": "open_out_bin", "kind": 12, "detail": "string => out_channel", "documentation": "Same as open_out, but the file is opened in binary mode, so that no translation takes place during writes. On operating systems that do not distinguish between text mode and binary mode, this function behaves like open_out.\n\n\n\nfile:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli:1"}, {"label": "output_substring", "kind": 12, "detail": "(out_channel, string, int, int) => unit", "documentation": "Same as `output` but take a string as argument instead of a byte sequence.\n\nSince: 4.02.0\n\nfile:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli:1"}, {"label": "output_byte", "kind": 12, "detail": "(out_channel, int) => unit", "documentation": "Write one 8-bit integer \\(as the single character with that code\\) on the given output channel. The given integer is taken modulo 256.\n\n\n\nfile:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli:1"}, {"label": "out_channel", "kind": 22, "detail": "type out_channel = Pervasives.out_channel", "documentation": "The type of output channel.\n\n\n\nfile:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli:1"}, {"label": "open_flag", "kind": 22, "detail": "type open_flag = \n  | Open_rdonly\n  | Open_wronly\n  | Open_append\n  | Open_creat\n  | Open_trunc\n  | Open_excl\n  | Open_binary\n  | Open_text\n  | Open_nonblock\n = Pervasives.open_flag", "documentation": "Opening modes for open_out_gen and open_in_gen.\n\n\n\nfile:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli:1"}]}
Running diagnostics for file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re
➡️ running compiler /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/bin/ocamlopt.opt -c -I '/Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml' -I '_build/default/.rwoLwt.eobjs/byte' -bin-annot -w @1..3@5..28@30..39@43@46..47@49..57@61..62-40 -strict-sequence -strict-formats -short-paths -keep-locs -impl /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/_build/.lsp/RwoLwt.ast with pwd /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
Now loading /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/_build/.lsp/RwoLwt.cmt
Size 1918
type error here File "", line 16, characters 0-1:
Error: Unbound value o
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re", "diagnostics": [{"range": {"start": {"line": 15, "character": 0}, "end": {"line": 15, "character": 1}}, "message": "Error: Unbound value o", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":18},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n/* The latest version of this document is available at https://github.com/dkim/rwo-lwt/. */\n/* Async Basics */\nopen \nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Read message 
{"jsonrpc":"2.0","id":81,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0138282775879ms
➡️ running compiler /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/bin/ocamlopt.opt -c -I '/Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml' -I '_build/default/.rwoLwt.eobjs/byte' -bin-annot -w @1..3@5..28@30..39@43@46..47@49..57@61..62-40 -strict-sequence -strict-formats -short-paths -keep-locs -impl /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/_build/.lsp/RwoLwt.ast with pwd /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
Now loading /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/_build/.lsp/RwoLwt.cmt
Size 1918
Sending response {"id": 81, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: ", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":82,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0159740447998ms
Sending response {"id": 82, "jsonrpc": "2.0", "result": []}
Running diagnostics for file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re", "diagnostics": [{"range": {"start": {"line": 16, "character": 0}, "end": {"line": 16, "character": 3}}, "message": "Error: 330: let is a reserved keyword, it cannot be used as an identifier. Try `let_` or `_let` instead", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":19},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n/* The latest version of this document is available at https://github.com/dkim/rwo-lwt/. */\n/* Async Basics */\nopen L\nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Read message 
{"jsonrpc":"2.0","id":83,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"position":{"line":15,"character":6},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0178813934326ms
Opens folkz > 1 L
Package opens Pervasives
Package opens Stdlib
FINDING docs for module IntfAndImpl(/Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.cmti, /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli, /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.cmt, /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.ml)
FINDING /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.cmti src /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli
resolving open L.place holder
Not local
No path for module L
Could not get module L
Opens nows 1 file:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli
---------------- LOCAL VAL
 - Completing in file:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli
Sending response {"id": 83, "jsonrpc": "2.0", "result": [{"label": "ListLabels", "kind": 9, "detail": "module", "documentation": "ListLabels\n\nfile:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli:1301"}, {"label": "LargeFile", "kind": 9, "detail": "module", "documentation": "Operations on large files. This sub-module provides 64-bit variants of the channel functions that manipulate file positions and file sizes. By representing positions and sizes by 64-bit integers \\(type `int64`\\) instead of regular integers \\(type `int`\\), these alternate functions allow operating on files whose sizes are greater than `max_int`.\n\n\n\nfile:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli:1"}, {"label": "Lazy", "kind": 9, "detail": "module", "documentation": "Lazy\n\nfile:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli:1292"}, {"label": "Lexing", "kind": 9, "detail": "module", "documentation": "Lexing\n\nfile:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli:1295"}, {"label": "List", "kind": 9, "detail": "module", "documentation": "List\n\nfile:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli:1298"}]}
Read message 
{"jsonrpc":"2.0","id":84,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0150203704834ms
➡️ running compiler /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/bin/ocamlopt.opt -c -I '/Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml' -I '_build/default/.rwoLwt.eobjs/byte' -bin-annot -w @1..3@5..28@30..39@43@46..47@49..57@61..62-40 -strict-sequence -strict-formats -short-paths -keep-locs -impl /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/_build/.lsp/RwoLwt.ast with pwd /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
Now loading /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/_build/.lsp/RwoLwt.cmt
Size 1918
Sending response {"id": 84, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: ", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":85,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"range":{"start":{"line":15,"character":6},"end":{"line":15,"character":6}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 85, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":86,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00882148742676ms
Sending response {"id": 86, "jsonrpc": "2.0", "result": []}
Running diagnostics for file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re
type error here File "", line 16, characters 5-6:
Error: Unbound module L
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re", "diagnostics": [{"range": {"start": {"line": 15, "character": 5}, "end": {"line": 15, "character": 6}}, "message": "Error: Unbound module L", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":20},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n/* The latest version of this document is available at https://github.com/dkim/rwo-lwt/. */\n/* Async Basics */\nopen Lw\nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Read message 
{"jsonrpc":"2.0","id":87,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0138282775879ms
➡️ running compiler /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/bin/ocamlopt.opt -c -I '/Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml' -I '_build/default/.rwoLwt.eobjs/byte' -bin-annot -w @1..3@5..28@30..39@43@46..47@49..57@61..62-40 -strict-sequence -strict-formats -short-paths -keep-locs -impl /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/_build/.lsp/RwoLwt.ast with pwd /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
Now loading /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/_build/.lsp/RwoLwt.cmt
Size 1918
Sending response {"id": 87, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: ", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":88,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"range":{"start":{"line":15,"character":7},"end":{"line":15,"character":7}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0119209289551ms
Sending response {"id": 88, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":89,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0801086425781ms
Sending response {"id": 89, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":21},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n/* The latest version of this document is available at https://github.com/dkim/rwo-lwt/. */\n/* Async Basics */\nopen Lwt\nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Read message 
{"jsonrpc":"2.0","id":90,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"position":{"line":15,"character":8},"context":{"triggerKind":1}}}
[server] Got a method textDocument/completion
[server] processing took 0.0119209289551ms
Opens folkz > 1 Lwt
Package opens Pervasives
Package opens Stdlib
FINDING docs for module IntfAndImpl(/Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.cmti, /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli, /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.cmt, /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.ml)
FINDING /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.cmti src /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli
resolving open Lwt.place holder
Not local
No path for module Lwt
Could not get module Lwt
Opens nows 1 file:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli
---------------- LOCAL VAL
 - Completing in file:///Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli
Sending response {"id": 90, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","id":91,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0109672546387ms
➡️ running compiler /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/bin/ocamlopt.opt -c -I '/Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml' -I '_build/default/.rwoLwt.eobjs/byte' -bin-annot -w @1..3@5..28@30..39@43@46..47@49..57@61..62-40 -strict-sequence -strict-formats -short-paths -keep-locs -impl /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/_build/.lsp/RwoLwt.ast with pwd /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
Now loading /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/_build/.lsp/RwoLwt.cmt
Size 1918
Sending response {"id": 91, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: ", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":92,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"range":{"start":{"line":15,"character":8},"end":{"line":15,"character":8}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0109672546387ms
Sending response {"id": 92, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":93,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0162124633789ms
Sending response {"id": 93, "jsonrpc": "2.0", "result": []}
Running diagnostics for file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re
type error here File "", line 16, characters 5-8:
Error: Unbound module Lwt
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re", "diagnostics": [{"range": {"start": {"line": 15, "character": 5}, "end": {"line": 15, "character": 8}}, "message": "Error: Unbound module Lwt", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":22},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n/* The latest version of this document is available at https://github.com/dkim/rwo-lwt/. */\n/* Async Basics */\nopen Lwt;\nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Read message 
{"jsonrpc":"2.0","id":94,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.00905990600586ms
➡️ running compiler /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/bin/ocamlopt.opt -c -I '/Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml' -I '_build/default/.rwoLwt.eobjs/byte' -bin-annot -w @1..3@5..28@30..39@43@46..47@49..57@61..62-40 -strict-sequence -strict-formats -short-paths -keep-locs -impl /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/_build/.lsp/RwoLwt.ast with pwd /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
Now loading /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/_build/.lsp/RwoLwt.cmt
Size 1918
Sending response {"id": 94, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: ", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":95,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.00715255737305ms
Sending response {"id": 95, "jsonrpc": "2.0", "result": []}
Read message 
{"jsonrpc":"2.0","id":96,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"range":{"start":{"line":15,"character":9},"end":{"line":15,"character":9}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00810623168945ms
Sending response {"id": 96, "jsonrpc": "2.0", "result": null}
Running diagnostics for file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re
type error here File "", line 16, characters 5-8:
Error: Unbound module Lwt
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re", "diagnostics": [{"range": {"start": {"line": 15, "character": 5}, "end": {"line": 15, "character": 8}}, "message": "Error: Unbound module Lwt", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":23},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n/* The latest version of this document is available at https://github.com/dkim/rwo-lwt/. */\n/* Async Basics */\nopen Lwt;\n\nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Read message 
{"jsonrpc":"2.0","id":97,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0159740447998ms
➡️ running compiler /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/bin/ocamlopt.opt -c -I '/Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml' -I '_build/default/.rwoLwt.eobjs/byte' -bin-annot -w @1..3@5..28@30..39@43@46..47@49..57@61..62-40 -strict-sequence -strict-formats -short-paths -keep-locs -impl /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/_build/.lsp/RwoLwt.ast with pwd /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
Now loading /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/_build/.lsp/RwoLwt.cmt
Size 1918
Sending response {"id": 97, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: ", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":98,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.0219345092773ms
Sending response {"id": 98, "jsonrpc": "2.0", "result": []}
Running diagnostics for file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re
type error here File "", line 16, characters 5-8:
Error: Unbound module Lwt
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re", "diagnostics": [{"range": {"start": {"line": 15, "character": 5}, "end": {"line": 15, "character": 8}}, "message": "Error: Unbound module Lwt", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":23},"contentChanges":[{"text":"/*\n * Concurrent Programming with Lwt\n *\n * Written in 2017 by Deokhwan Kim\n *\n * To the extent possible under law, the author(s) have dedicated all copyright\n * and related and neighboring rights to this software to the public domain\n * worldwide. This software is distributed without any warranty.\n *\n * You should have received a copy of the CC0 Public Domain Dedication along\n * with this software. If not, see\n * <http://creativecommons.org/publicdomain/zero/1.0/>.\n */\n/* The latest version of this document is available at https://github.com/dkim/rwo-lwt/. */\n/* Async Basics */\nopen Lwt;\n\nlet file_contents = (filename: Lwt_io.file_name): Lwt.t(string) =>\n  Lwt_io.with_file(~mode=Lwt_io.input, filename, channel =>\n    Lwt_io.read(channel)\n  );\n\nlet save = (filename: Lwt_io.file_name, ~contents: string): Lwt.t(unit) =>\n  Lwt_io.with_file(~mode=Lwt_io.output, filename, channel =>\n    Lwt_io.write(channel, contents)\n  );\n\nlet uppercase_file = (filename: Lwt_io.file_name): Lwt.t(unit) => {\n  let%lwt text = file_contents(filename);\n  save(filename, ~contents=String.uppercase_ascii(text));\n};\n\nlet count_lines = (filename: Lwt_io.file_name): Lwt.t(int) => {\n  let%lwt text = file_contents(filename);\n  String.split_on_char('\\n', text) |> List.length |> Lwt.return;\n};\n\n/* Ivars and Upon */\n\nmodule type Delayer_intf = {\n  type t;\n  let create: float => t;\n  let schedule: (t, unit => Lwt.t('a)) => Lwt.t('a);\n};\n\nmodule Delayer: Delayer_intf = {\n  type t = {\n    delay: float,\n    jobs: Queue.t(unit => unit),\n  };\n\n  let create = (delay: float): t => {delay, jobs: Queue.create()};\n\n  let schedule = (t: t, thunk: unit => Lwt.t('a)): Lwt.t('a) => {\n    let (waiter, wakener) = Lwt.wait();\n    Queue.add(\n      () =>\n        Lwt.on_any(thunk(), Lwt.wakeup(wakener), Lwt.wakeup_exn(wakener)),\n      t.jobs,\n    );\n    Lwt.on_termination(Lwt_unix.sleep(t.delay), Queue.take(t.jobs));\n    waiter;\n  };\n};\n\n/* Example: An Echo Server */\n\nlet rec copy_blocks =\n        (buffer: bytes, r: Lwt_io.input_channel, w: Lwt_io.output_channel)\n        : Lwt.t(unit) =>\n  switch%lwt (Lwt_io.read_into(r, buffer, 0, Bytes.length(buffer))) {\n  | 0 => Lwt.return_unit\n  | bytes_read =>\n    let%lwt () = Lwt_io.write_from_exactly(w, buffer, 0, bytes_read);\n    copy_blocks(buffer, r, w);\n  };\n\n/*\n let run () : unit =\n   ((let%lwt server =\n       Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, 8765))\n         (fun (r, w) ->\n            let buffer = Bytes.create (16 * 1024) in\n            copy_blocks buffer r w)\n     in\n     Lwt.return server) : Lwt_io.server Lwt.t) |> ignore\n */\n\nlet never_terminate: 'a. Lwt.t('a) = fst(Lwt.wait());\n\n/*\n let () =\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   run ();\n   Lwt_main.run never_terminate\n */\n\n/* Improving the Echo Server */\n\nlet run = (uppercase: bool, port: int): Lwt.t(unit) => {\n  let%lwt server =\n    Lwt_io.establish_server(\n      [@implicit_arity] Lwt_unix.ADDR_INET(Unix.inet_addr_any, port),\n      ((r, w)) =>\n      Lwt_io.read_chars(r)\n      |> (\n        if (uppercase) {\n          Lwt_stream.map(Char.uppercase_ascii);\n        } else {\n          x => x;\n        }\n      )\n      |> Lwt_io.write_chars(w)\n    );\n\n  (server: Lwt_io.server) |> ignore;\n  never_terminate;\n};\n\n/*\n let run (uppercase : bool) (port : int) : unit Lwt.t =\n   let%lwt server =\n     Lwt_io.establish_server (Lwt_unix.ADDR_INET (Unix.inet_addr_any, port))\n       (fun (r, w) ->\n          let reader = Lwt_pipe.IO.read r in\n          let writer =\n            Lwt_pipe.IO.write w\n            |> (if uppercase then Lwt_pipe.Writer.map ~f:String.uppercase_ascii\n                else fun x -> x)\n          in\n          Lwt_pipe.connect ~ownership:`OutOwnsIn reader writer;\n          Lwt_pipe.wait writer)\n   in\n   (server : Lwt_io.server) |> ignore;\n   never_terminate\n */\n\n/*\n let () =\n   let uppercase = ref false\n   and port = ref 8765 in\n   let options =\n     Arg.align [\n       (\"-uppercase\",\n        Arg.Set uppercase,\n        \" Convert to uppercase before echoing back\");\n       (\"-port\",\n        Arg.Set_int port,\n        \"num Port to listen on (default 8765)\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-uppercase] [-port num]\" in\n   Arg.parse\n     options\n     (fun arg -> raise (Arg.Bad (Printf.sprintf \"invalid argument -- '%s'\" arg)))\n     usage;\n\n   Sys.set_signal Sys.sigpipe Sys.Signal_ignore;\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (run !uppercase !port)\n */\n\n/* Example: Searching Definitions with DuckDuckGo */\n\n/* URI Handling */\n\n/*\n let query_uri : string -> Uri.t =\n   let base_uri = Uri.of_string \"https://api.duckduckgo.com/?format=json\" in\n   (fun query -> Uri.add_query_param base_uri (\"q\", [query]))\n */\n\n/* Parsing JSON Strings */\n\nlet get_definition_from_json = (json: string): option(string) =>\n  switch (Yojson.Safe.from_string(json)) {\n  | `Assoc(kv_list) =>\n    let find = key =>\n      switch (List.assoc(key, kv_list)) {\n      | exception Not_found => None\n      | `String(\"\") => None\n      | s => Some(Yojson.Safe.to_string(s))\n      };\n\n    switch (find(\"Abstract\")) {\n    | Some(_) as x => x\n    | None => find(\"Definition\")\n    };\n  | _ => None\n  };\n\n/* Executing an HTTP Client Query */\n\n/*\n let get_definition (word : string) : (string * string option) Lwt.t =\n   let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri word) in\n   let%lwt body' = Cohttp_lwt_body.to_string body in\n   Lwt.return (word, get_definition_from_json body')\n\n let print_result ((word, definition) : string * string option) : unit Lwt.t =\n   Lwt_io.printf \"%s\\n%s\\n\\n%s\\n\\n\"\n     word\n     (String.init (String.length word) (fun _ -> '-'))\n     (match definition with\n      | None -> \"No definition found\"\n      | Some def ->\n        Format.pp_set_margin Format.str_formatter 70;\n        Format.pp_print_text Format.str_formatter def;\n        Format.flush_str_formatter ())\n\n let search_and_print (words : string list) : unit Lwt.t =\n   let%lwt results = Lwt_list.map_p get_definition words in\n   Lwt_list.iter_s print_result results\n\n (*\n let search_and_print (words : string list) : unit Lwt.t =\n   Lwt_list.iter_p\n     (fun word ->\n        let%lwt result = get_definition word in\n        print_result result)\n     words\n *)\n\n let () =\n   let words = ref [] in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [word ...]\" in\n   Arg.parse [] (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print !words)\n */\n\n/* Example: Handling Exceptions with DuckDuckGo */\n\nlet query_uri = (~server: string, query: string): Uri.t => {\n  let base_uri =\n    Uri.of_string(String.concat(\"\", [\"https://\", server, \"/?format=json\"]));\n\n  Uri.add_query_param(base_uri, (\"q\", [query]));\n};\n\n/*\n let get_definition ~(server : string) (word : string) : (string * (string option, string) result) Lwt.t =\n   try%lwt\n     let%lwt _resp, body = Cohttp_lwt_unix.Client.get (query_uri ~server word) in\n     let%lwt body' = Cohttp_lwt_body.to_string body in\n     Lwt.return (word, Ok (get_definition_from_json body'))\n   with _ -> Lwt.return (word, Error \"Unexpected failure\")\n */\n\nlet print_result =\n    ((word, definition): (string, result(option(string), string)))\n    : Lwt.t(unit) =>\n  Lwt_io.printf(\n    \"%s\\n%s\\n\\n%s\\n\\n\",\n    word,\n    String.init(String.length(word), _ => '-'),\n    switch (definition) {\n    | Error(s) => \"DuckDuckGo query failed: \" ++ s\n    | Ok(None) => \"No definition found\"\n    | Ok(Some(def)) =>\n      Format.pp_set_margin(Format.str_formatter, 70);\n      Format.pp_print_text(Format.str_formatter, def);\n      Format.flush_str_formatter();\n    },\n  );\n\n/*\n let search_and_print ~(servers : string list) (words : string list) : unit Lwt.t =\n   let servers = Array.of_list servers in\n   let%lwt results =\n     Lwt_list.mapi_p\n       (fun i word ->\n          let server = servers.(i mod Array.length servers) in\n          get_definition ~server word)\n       words\n   in\n   Lwt_list.iter_s print_result results\n\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !words)\n */\n\n/* Timeouts, Cancellation, and Choices */\n\nlet get_definition =\n    (~server: string, word: string)\n    : Lwt.t((string, result(option(string), exn))) =>\n  try%lwt(\n    {\n      let%lwt (_resp, body) =\n        Cohttp_lwt_unix.Client.get(query_uri(~server, word));\n      let%lwt body' = Cohttp_lwt_body.to_string(body);\n      Lwt.return((word, Ok(get_definition_from_json(body'))));\n    }\n  ) {\n  | exn => Lwt.return((word, Error(exn)))\n  };\n\nlet get_definition_with_timeout =\n    (~server: string, timeout: float, word: string)\n    : Lwt.t((string, result(option(string), string))) =>\n  Lwt.pick([\n    {\n      let%lwt () = Lwt_unix.sleep(timeout);\n      Lwt.return((word, Error(\"Timed out\")));\n    },\n    {\n      let%lwt (word, result) = get_definition(~server, word);\n      let result' =\n        switch (result) {\n        | Ok(_) as x => x\n        | Error(_) => Error(\"Unexpected failure\")\n        };\n\n      Lwt.return((word, result'));\n    },\n  ]);\n\nlet search_and_print =\n    (~servers: list(string), timeout: float, words: list(string))\n    : Lwt.t(unit) => {\n  let servers = Array.of_list(servers);\n  let%lwt results =\n    Lwt_list.mapi_p(\n      (i, word) => {\n        let server = servers[i mod Array.length(servers)];\n        get_definition_with_timeout(~server, timeout, word);\n      },\n      words,\n    );\n\n  Lwt_list.iter_s(print_result, results);\n};\n\n/*\n let () =\n   let servers = ref [\"api.duckduckgo.com\"]\n   and timeout = ref 5.0\n   and words = ref [] in\n   let options =\n     Arg.align [\n       (\"-servers\",\n        Arg.String (fun s -> servers := String.split_on_char ',' s),\n        \"s1,...,sn Specify servers to connect to\");\n       (\"-timeout\",\n        Arg.Set_float timeout,\n        \"secs Abandon queries that take longer than this time\");\n     ]\n   in\n   let usage = \"Usage: \" ^ Sys.executable_name ^ \" [-servers s1,...,sn] [-timeout secs] [word ...]\" in\n   Arg.parse options (fun w -> words := w :: !words) usage;\n   words := List.rev !words;\n\n   (try Lwt_engine.set (new Lwt_engine.libev ())\n    with Lwt_sys.Not_available _ -> ());\n   Lwt_main.run (search_and_print ~servers:!servers !timeout !words)\n */\n\n/* Working with System Threads */\n\nlet rec every =\n        (\n          ~stop: Lwt.t(unit)=never_terminate,\n          span: float,\n          f: unit => Lwt.t(unit),\n        )\n        : Lwt.t(unit) =>\n  if (Lwt.is_sleeping(stop)) {\n    let%lwt () = f();\n    let%lwt () = Lwt.pick([Lwt_unix.sleep(span), Lwt.protected(stop)]);\n    every(~stop, span, f);\n  } else {\n    Lwt.return_unit;\n  };\n\nlet log_delays = (thunk: unit => Lwt.t(unit)): Lwt.t(unit) => {\n  let start = Unix.gettimeofday();\n  let print_time = () => {\n    let diff = Unix.gettimeofday() -. start;\n    Lwt_io.printf(\"%f, \", diff);\n  };\n\n  let d = thunk();\n  let%lwt () = every(0.1, ~stop=d, print_time);\n  let%lwt () = d;\n  let%lwt () = print_time();\n  Lwt_io.print(\"\\n\");\n};\n\nlet noalloc_busy_loop = (): unit =>\n  for (_i in 0 to 10_000_000_000) {\n    ();\n  };\n\nlet () =\n  Lwt_main.run @@\n  log_delays(() => Lwt_preemptive.detach(noalloc_busy_loop, ()));\n"}]}}
Running diagnostics for file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re
➡️ running compiler /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/bin/ocamlopt.opt -c -I '/Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml' -I '_build/default/.rwoLwt.eobjs/byte' -bin-annot -w @1..3@5..28@30..39@43@46..47@49..57@61..62-40 -strict-sequence -strict-formats -short-paths -keep-locs -impl /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/_build/.lsp/RwoLwt.ast with pwd /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example
Now loading /Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/_build/.lsp/RwoLwt.cmt
Size 1918
type error here File "", line 16, characters 5-8:
Error: Unbound module Lwt
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re", "diagnostics": [{"range": {"start": {"line": 15, "character": 5}, "end": {"line": 15, "character": 8}}, "message": "Error: Unbound module Lwt", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re","version":23}}}
Read message 
{"jsonrpc":"2.0","id":99,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/rwoLwt.re"},"position":{"line":11,"character":22}}}
[server] Got a method textDocument/hover
[server] processing took 0.0159740447998ms
Sending response {"id": 99, "jsonrpc": "2.0", "result": null}
>> Build system running: opam exec -- dune build @install --root .
>>> stdout

>>> stderr

Affected files: 
Cleaning bsconfig.json
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/bsconfig.json", "diagnostics": []}}
Read message 
{"jsonrpc":"2.0","id":100,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune/hello_world.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0259876251221ms
Sending response {"id": 100, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":101,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune/hello_world.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0171661376953ms
Sending response {"id": 101, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Stdlib", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":102,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune/hello_world.ml"},"range":{"start":{"line":1,"character":20},"end":{"line":1,"character":20}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.00882148742676ms
Sending response {"id": 102, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/hello-world-dune/hello_world.ml"}}}
Read message 
{"jsonrpc":"2.0","method":"workspace/didChangeWatchedFiles","params":{"changes":[{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/.merlin","type":2},{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/realworldocaml-lwt-example/_build/default/.merlin","type":2}]}}
Got a watched file change
Read message 
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/counter_server.ml","languageId":"ocaml","version":1,"text":"(** Multi-client server example.\n\n    Clients can increment a shared counter or read its current value.\n\n    Build with: ocamlfind ocamlopt -package lwt,lwt.unix,logs,logs.lwt -linkpkg -o counter-server ./counter-server.ml\n *)\n\nopen Lwt\n\n(* Shared mutable counter *)\nlet counter = ref 0\n\nlet listen_address = Unix.inet_addr_loopback\nlet port = 9000\nlet backlog = 10\n\n\nlet handle_message msg =\n    match msg with\n    | \"read\" -> string_of_int !counter\n    | \"inc\"  -> counter := !counter + 1; \"Counter has been incremented\"\n    | _      -> \"Unknown command\"\n\nlet rec handle_connection ic oc () =\n    Lwt_io.read_line_opt ic >>=\n    (fun msg ->\n        match msg with\n        | Some msg ->\n            let reply = handle_message msg in\n            Lwt_io.write_line oc reply >>= handle_connection ic oc\n        | None -> Logs_lwt.info (fun m -> m \"Connection closed\") >>= return)\n\nlet accept_connection conn =\n    let fd, _ = conn in\n    let ic = Lwt_io.of_fd ~mode:Lwt_io.Input fd in\n    let oc = Lwt_io.of_fd ~mode:Lwt_io.Output fd in\n    Lwt.on_failure (handle_connection ic oc ()) (fun e -> Logs.err (fun m -> m \"%s\" (Printexc.to_string e) ));\n    Logs_lwt.info (fun m -> m \"New connection\") >>= return\n(* let accept_connection conn =\n  let fd, _ = conn in\n  let input_console = Lwt_io.of_fd Lwt_io.Input fd in\n  let output_console = Lwt_io.of_fd Lwt_io.Output fd in\n  Lwt.on_failure (handle_connection input_console output_console 0 ())\n    (fun e -> Logs.err (fun m -> m \"%s\" (Printexc.to_string e)));\n  Logs_lwt.info (fun m -> m \"New connection\") >>= return *)\n(*\nlet create_socket () =\n  let open Lwt_unix in\n  let sock = socket PF_INET SOCK_STREAM 0 in\n  (bind sock @@ ADDR_INET(listen_address, port);\n   listen sock backlog;\n   sock) *)\nlet create_socket () =\n    let open Lwt_unix in\n    let sock = socket PF_INET SOCK_STREAM 0 in\n    ignore @@ bind sock @@ ADDR_INET(listen_address, port);\n    || maybe ADDR_INET(listen_address, port) |> bind sock\n\nlet create_server sock =\n    let rec serve () =\n        Lwt_unix.accept sock >>= accept_connection >>= serve\n    in serve\n\nlet () =\n    let () = Logs.set_reporter (Logs.format_reporter ()) in\n    let () = Logs.set_level (Some Logs.Info) in\n    let sock = create_socket () in\n    let serve = create_server sock in\n    Lwt_main.run @@ serve ()\n\n"}}}
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/random.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/nat.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/map.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/topdirs.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/genlex.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stack.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/hashtbl.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/parsing.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/parsing.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/arith_status.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stream.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/callback.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/random.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/lazy.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/format.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_bytes.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_unix.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_io.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/list.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/string.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stringLabels.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalOO.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_throttle.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/arg.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_switch.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/gc.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_process.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/bytes.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_pool.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_features.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/marshal.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/format.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_condition.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/listLabels.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/list.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/sort.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/logs/logs.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_result.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/digest.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/oo.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/printexc.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/hashtbl.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/scanf.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/uchar.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/nativeint.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/raw_spacetime_lib.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/bigarray.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/set.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_gc.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/bytes.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalLazy.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_sequence.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_timeout.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/condition.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stream.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalOO.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/logs/logs_lwt.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/str.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/map.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_list.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/float.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/char.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/queue.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/seq.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/arrayLabels.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/sys.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_pool.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/listLabels.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/callback.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/printf.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/oo.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/spacetime.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_bytes.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocplib-endian/endianString.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/complex.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalFormatBasics.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_mutex.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/genlex.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/unixLabels.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/logs/logs_fmt.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdLabels.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/buffer.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/array.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/logs/logs_threaded.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/logs/logs_browser.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalFormat.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/uchar.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_engine.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/lexing.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/int64.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_config.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_sys.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalFormatBasics.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/mmap/mmap.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocplib-endian/endianBigstring.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/sort.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_process.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/thread.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stack.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalLazy.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/char.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_sys.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_stream.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/printf.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/big_int.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/result/result.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/set.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/array.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_engine.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocplib-endian/endianBytes.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_gc.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/string.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/std_exit.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/buffer.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/float.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_preemptive.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/filename.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_timeout.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/bigarray.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/scanf.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/sys.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/obj.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/num.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/weak.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_io.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/moreLabels.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/lexing.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/queue.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_fmt.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_main.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_mvar.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_throttle.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/int32.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_condition.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/filename.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/arg.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/lazy.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/arrayLabels.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_preemptive.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_pqueue.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_unix.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalMod.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_result.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_mvar.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/gc.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_fmt.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/mmap/mmap.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/obj.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/complex.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/ephemeron.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/bytesLabels.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/digest.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/event.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/ephemeron.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/bytesLabels.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/spacetime.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/printexc.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/marshal.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/unix.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/nativeint.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stringLabels.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/logs/logs_cli.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/unix/lwt_main.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_pqueue.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/int32.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_stream.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_mutex.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/mutex.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalMod.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/camlinternalFormat.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/seq.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/int64.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdlib.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/threadUnix.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_list.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/stdLabels.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/weak.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_switch.ml
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/lwt/lwt_sequence.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/dynlink.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/moreLabels.mli
 > /Users/prisc_000/.opam/ocaml-base-compiler.4.07.1/lib/ocaml/ratio.mli
Reloading because you created a new file: /Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/counter_server.ml
Read message 
{"jsonrpc":"2.0","id":103,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/counter_server.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":0,"character":0}},"context":{"diagnostics":[]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0231266021729ms
Sending response {"id": 103, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","id":104,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/counter_server.ml"}}}
[server] Got a method textDocument/documentSymbol
[server] processing took 0.014066696167ms
Sending response {"id": 104, "jsonrpc": "2.0", "result": [{"name": "accept_connection", "kind": 12, "location": {"range": {"start": {"line": 32, "character": 0}, "end": {"line": 37, "character": 58}}, "uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/_build/.lsp/Counter_server.ast"}}, {"name": "handle_connection", "kind": 12, "location": {"range": {"start": {"line": 23, "character": 0}, "end": {"line": 30, "character": 76}}, "uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/_build/.lsp/Counter_server.ast"}}, {"name": "handle_message", "kind": 12, "location": {"range": {"start": {"line": 17, "character": 0}, "end": {"line": 21, "character": 33}}, "uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/_build/.lsp/Counter_server.ast"}}, {"name": "backlog", "kind": 13, "location": {"range": {"start": {"line": 14, "character": 0}, "end": {"line": 14, "character": 16}}, "uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/_build/.lsp/Counter_server.ast"}}, {"name": "port", "kind": 13, "location": {"range": {"start": {"line": 13, "character": 0}, "end": {"line": 13, "character": 15}}, "uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/_build/.lsp/Counter_server.ast"}}, {"name": "listen_address", "kind": 13, "location": {"range": {"start": {"line": 12, "character": 0}, "end": {"line": 12, "character": 44}}, "uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/_build/.lsp/Counter_server.ast"}}, {"name": "counter", "kind": 13, "location": {"range": {"start": {"line": 10, "character": 0}, "end": {"line": 10, "character": 19}}, "uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/_build/.lsp/Counter_server.ast"}}]}
Read message 
{"jsonrpc":"2.0","id":105,"method":"textDocument/codeLens","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/counter_server.ml"}}}
[server] Got a method textDocument/codeLens
[server] processing took 0.0128746032715ms
Sending response {"id": 105, "jsonrpc": "2.0", "result": [{"range": {"start": {"line": 0, "character": 0}, "end": {"line": 0, "character": 0}}, "command": {"title": "Dependencies: Logs_lwt, Unix, Logs, Stdlib, Lwt_unix, CamlinternalFormatBasics, Lwt_io, Lwt", "command": ""}}, {"range": {"start": {"line": 32, "character": 4}, "end": {"line": 32, "character": 21}}, "command": {"title": "((Lwt_unix.file_descr, 'a)) => Lwt.t(\n  unit\n)", "command": ""}}, {"range": {"start": {"line": 23, "character": 8}, "end": {"line": 23, "character": 25}}, "command": {"title": "(\n  Lwt_io.input_channel,\n  Lwt_io.output_channel,\n  unit\n) => Lwt.t(unit)", "command": ""}}, {"range": {"start": {"line": 17, "character": 4}, "end": {"line": 17, "character": 18}}, "command": {"title": "string => string", "command": ""}}, {"range": {"start": {"line": 14, "character": 4}, "end": {"line": 14, "character": 11}}, "command": {"title": "int", "command": ""}}, {"range": {"start": {"line": 13, "character": 4}, "end": {"line": 13, "character": 8}}, "command": {"title": "int", "command": ""}}, {"range": {"start": {"line": 12, "character": 4}, "end": {"line": 12, "character": 18}}, "command": {"title": "Unix.inet_addr", "command": ""}}, {"range": {"start": {"line": 10, "character": 4}, "end": {"line": 10, "character": 11}}, "command": {"title": "Stdlib.ref(int)", "command": ""}}, {"range": {"start": {"line": 7, "character": 5}, "end": {"line": 7, "character": 8}}, "command": {"title": "Unused open", "command": ""}}]}
Read message 
{"jsonrpc":"2.0","id":106,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/counter_server.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":70,"character":0}},"context":{"diagnostics":[{"range":{"start":{"line":55,"character":4},"end":{"line":55,"character":58}},"message":"Error: This expression has type unit but an expression was expected of type\n         bool","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0150203704834ms
Sending response {"id": 106, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":103}}
Running diagnostics for file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/counter_server.ml
type error here File "/Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/_build/.lsp/Counter_server.ast", line 56, characters 4-58:
Error: This expression has type unit but an expression was expected of type
         bool
Sending notification {"jsonrpc": "2.0", "method": "textDocument/publishDiagnostics", "params": {"uri": "file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/counter_server.ml", "diagnostics": [{"range": {"start": {"line": 55, "character": 4}, "end": {"line": 55, "character": 58}}, "message": "Error: This expression has type unit but an expression was expected of type\n         bool", "severity": 1}]}}
Read message 
{"jsonrpc":"2.0","id":107,"method":"textDocument/codeAction","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/counter_server.ml"},"range":{"start":{"line":0,"character":0},"end":{"line":70,"character":0}},"context":{"diagnostics":[{"range":{"start":{"line":55,"character":4},"end":{"line":55,"character":58}},"message":"Error: This expression has type unit but an expression was expected of type\n         bool","severity":1}]}}}
[server] Got a method textDocument/codeAction
[server] processing took 0.0159740447998ms
Sending response {"id": 107, "jsonrpc": "2.0", "result": null}
Read message 
{"jsonrpc":"2.0","method":"textDocument/didClose","params":{"textDocument":{"uri":"file:///Users/prisc_000/working/GitHub/reason-native-hello-world/lwt-counter-server-ml/counter_server.ml"}}}
